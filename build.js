#!/usr/bin/env node
// Generates decks/decks.js from manifest.json + .md files.
// Usage:
//   node build.js          — build once
//   node build.js --watch  — rebuild whenever a .md or manifest.json changes
'use strict';

const fs   = require('fs');
const path = require('path');

const ROOT     = __dirname;
const MANIFEST = path.join(ROOT, 'decks', 'manifest.json');
const OUT      = path.join(ROOT, 'decks', 'decks.js');

function build() {
  let manifest;
  try { manifest = JSON.parse(fs.readFileSync(MANIFEST, 'utf8')); }
  catch(e) { console.error('Could not read manifest.json:', e.message); return; }

  let out = '// Auto-generated by build.js — do not edit directly.\n'
          + '// Edit deck content in decks/*.md and register in decks/manifest.json.\n\n';

  let n = 0;
  for (const entry of manifest.decks) {
    const src = path.join(ROOT, 'decks', entry.file);
    if (!fs.existsSync(src)) { console.warn(`  ⚠  ${entry.file} not found — skipped`); continue; }

    let content = fs.readFileSync(src, 'utf8');
    // Escape for a JS template literal: backslashes, backticks, ${ sequences
    content = content
      .replace(/\\/g,  '\\\\')
      .replace(/`/g,   '\\`')
      .replace(/\$\{/g, '\\${');

    out += `deck(\`${content}\`);\n\n`;
    n++;
  }

  fs.writeFileSync(OUT, out);
  const t = new Date().toLocaleTimeString();
  console.log(`${t}  built decks/decks.js  (${n} deck${n !== 1 ? 's' : ''})`);
}

build();

if (process.argv.includes('--watch')) {
  console.log('Watching decks/ for changes… (Ctrl-C to stop)\n');
  let timer = null;
  fs.watch(path.join(ROOT, 'decks'), { persistent: true }, (_, filename) => {
    if (!filename) return;
    if (!filename.endsWith('.md') && filename !== 'manifest.json') return;
    clearTimeout(timer);
    timer = setTimeout(build, 80); // debounce rapid saves
  });
}
